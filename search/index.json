{"results":[{"href":"https://gophers-latam.github.io/posts/2023/10/el-tour-de-go-ahora-en-espa%C3%B1ol/","title":"El tour de Go ahora en Espa√±ol","body":" Tour de Go en Espa√±ol ¬°Logramos algo incre√≠ble como comunidad! La traducci√≥n del tour de Go al espa√±ol. Estamos emocionados de compartir con todos ustedes el incre√≠ble logro que hemos alcanzado juntos: la completa traducci√≥n del tour de Go al espa√±ol.\nEste proyecto fue un esfuerzo colaborativo en el que nuestra comunidad contribuy√≥ con su tiempo y conocimiento para hacer que esta herramienta est√© disponible para toda la comunidad hispanohablante. ¬°El resultado es asombroso!\n¬øQu√© es El Tour de Go? üë©‚Äçüíªüë®‚Äçüíª Para aquellos que a√∫n no lo conocen, el \u0026ldquo;Tour de Go\u0026rdquo; es una excelente introducci√≥n al lenguaje de programaci√≥n Go. Proporciona ejemplos interactivos y explicaciones detalladas, lo que lo convierte en una herramienta invaluable para aprender Go.\nEl poder de la colaboraci√≥n üë• La clave de este logro fue la colaboraci√≥n. Cada uno de nosotros aport√≥ con sus habilidades y conocimientos para llevar a cabo esta traducci√≥n. Desde los que realizaron las primeras traducciones hasta aquellos que revisaron y pulieron cada detalle, cada uno de ustedes fue fundamental.\n¬øQu√© significa esto para la comunidad? üí° La traducci√≥n del tour al espa√±ol no solo significa que m√°s personas tendr√°n acceso a esta valiosa herramienta, sino que tambi√©n fortalece nuestra comunidad y nos posiciona como un grupo que puede lograr grandes cosas cuando trabajamos juntos.\n¬øQu√© sigue? üõ†Ô∏è Nuestro trabajo no termina aqu√≠. Continuaremos buscando maneras de contribuir y crecer como comunidad. Si tienes ideas o proyectos en mente, ¬°no dudes en compartirlas!\nUna vez m√°s, felicitaciones a todos los que participaron en este proyecto. ¬°Han demostrado el incre√≠ble poder de la comunidad de Gophers Latam!\n¬°Sigamos construyendo juntos! üöÄ Tour de Go Link del repositorio: https://github.com/gophers-latam/go-tour-es\nLink profesional sobre la comunidad: https://es.linkedin.com/posts/thiago-mowszet_github-gophers-latamgo-tour-es-traducci%C3%B3n-activity-7118450478593536000-JlrR\n"},{"href":"https://gophers-latam.github.io/posts/2023/03/handlers-con-timeout/","title":"Handlers Con Timeout","body":" go handlers En algunas oportunidades, vamos a necesitar un comportamiento muy determin√≠stico en nuestras APIs, ya sea porque el negocio as√≠ lo requiere o los clientes. Tal vez, un comportamiento que se mantenga alejado de cualquier sorpresa, puede ser el m√°ximo de duraci√≥n que le queremos dejar como ventana para que un respuesta sea entregada, en caso de excederlo, ahora si como el t√≠tulo lo dice, devolvemos un timeout\u0026hellip; pero, qu√© es un timeout?\nEn principio sabemos que contamos con 2 estados para representarlo, pero no se parecen mucho ya que est√°n en centenas distintas, unos es 408 request timeout y el otro es 504 Gateway timeout. Si leemos un poco las especificaciones, ninguno de los dos nos calza justo para lo que queremos, el 408 nos dice que el cliente \u0026ldquo;se tard√≥ demasiado para enviar su request\u0026rdquo;, desde la RFC dice lo siguiente:\nThe client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time.\nY para su contraparte del lado del servidor:\nThe server was acting as a gateway or proxy and did not receive a timely response from the upstream server.\nEntonces, para la responder la pregunta, concluimos que un timeout es que esperamos demasiado por algo, y no sucedi√≥, ademas, lo consideramos un error.\nC√≥mo hacemos nuestras funciones de Timeout? En los lenguajes de programaci√≥n modernos, encontramos built-in algunas formas de manejar estos casos de uso. En Golang, por ejemplo el paquete context tiene constructores para crear uno que expire y se cancele despu√©s de cierto tiempo.\nDentro del paquete net/http tambi√©n nos encontramos con muchos timeouts como por ejemplo en la struct http.Client para hacer requests y http.Server es otra que tampoco se queda afuera de tener este tipo de configuraci√≥n.\nPor ahora, tenemos: context, http.Client y Server, servidores TCP y UDP, etc. Podemos resumir que siempre que haya una conexi√≥n hacia fuera (ya sea cliente o servidor) vamos a poder configurar un timeout.\nC√≥mo nos sirven en los web handlers? Antes, debemos aclarar que es un middleware, en cualquier lenguaje, ya que es un concepto y no una implementaci√≥n espec√≠fica de Golang.\nEntonces, decimos que son funciones con la misma firma que un handler (o controlador web), que recibe los mismos par√°metros para operar como una petici√≥n HTTP. Al ser iguales, nos permite ejecutarlo previamente de una forma sencilla y pre-ejecutar operaciones que nos ayuden a nuestro negocio. Un claro ejemplo son validaciones de token JWT, agregar request ID unicos, sumarle datos al contexto (esto si es mas estilo gopher). En nuestro caso, vamos a tener un middleware que se encargue de reemplazar el contexto, por otro que tenga un timeout, para que no tarde mas de tanto tiempo y si no, falla. Nos va a ayudar a garantizar un tiempo de respuesta de m√°xima, por las buenas o por las malas.\nLo llevamos a c√≥digo Como middleware, podemos usar uno que ya existe y est√° dentro del paquete http, es http.Timeout y dentro de su firma, vamos a pasarle un http.Handler, el tiempo de espera que vamos a soportar y por √∫ltimo (este no me gusta mucho) un mensaje como string, donde nos quita un poco de flexibilidad, a mi entender, []byte nos dar√≠a un espectro mas amplio a la hora de retornar los valores.\nPodemos implementarlo como un wrapper general a todo el multiplexer y que todos ejecuten el middleware, este tiene como ventaja que escribimos una sola vez, pero perdemos granularidad. func main() { mux := http.NewServeMux() mux.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { //.... }) muxWithMiddleware := http.TimeoutHandler(mux, time.Second*5, \u0026#34;timeout!\u0026#34;) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, muxWithMiddleware)) } Por √∫ltimo, tenemos otro camino, para tener un control esperc√≠fico en cada handler que expongamos. func main() { mux := http.NewServeMux() helloHandler := http.TimeoutHandler(wrapHandlerFunc(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { _, _ = w.Write([]byte(\u0026#34;hello with timeout!\u0026#34;)) })), time.Second*5, \u0026#34;timeout\u0026#34;) mux.Handle(\u0026#34;/\u0026#34;, helloHandler) } func wrapHandlerFunc(handler http.Handler) http.Handler { wrapped := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) handler.ServeHTTP(w, r) }) return wrapped } Conclusiones Vemos la flexibilidad que tenemos para exponer funciones en un servior web que tenemos en Golang. Siempre nos da muchas facilidades y opciones, a su vez, puede ser un poco confuso porque no sabemos bien cual usar. Como peque√±o consejo, no nos fritemos la cabeza pensando y comparando, tan solo elijamos una con un an√°lisis superficial y despues nos queda el aprendizaje.\nPara cerrar el tema t√©cnico, estamos re-utilizando una funcion de la stdlib de Go, por lo que no es necesario que nostros pensemos esa l√≥gica, tambi√©n, muchos de los Frameworks web como Echo, Gin y Fiber (seguramente entre varios otros) ya traen sus middleware de timeout y es de una implementacion muy similar a la que acabamos de ver.\nEspero que les haya gustado la explicaci√≥n! nos vemos dentro de poco y cualquier tema que quieran que tratemos lo pueden dejar en comentarios.\n"},{"href":"https://gophers-latam.github.io/posts/2022/08/intro-go-mistakes-okno/","title":"Intro Go Mistakes Okno","body":" okno Se comparte el concepto o contexto de algunos errores basicos con su definici√≥n acompa√±ado de ejemplo y soluci√≥n.\nIndice: C√≥digo y organizaci√≥n del proyecto C√≥digo y organizaci√≥n del proyecto - Sombreado de variable (shadowing) no deseado La parte de una aplicaci√≥n donde un enlace de nombre es v√°lido. En Go, un nombre de variable declarado en un bloque se puede volver a declarar en un bloque interno. Este principio, llamado sombreado de variable, es propenso a errores.\nEjemplo:\nvar client *http.Client if tracing { client, err := createClientWithTracing() if err != nil { return err } log.Println(client) } else { client, err := createDefaultClient() if err != nil { return err } log.Println(client) } 1 Declarar una variable client 2 Crear un cliente HTTP con tracing habilitado, la variable client est√° sombreada en este bloque 3 Crear un cliente HTTP predeterminado, la variable client tambi√©n se sombrea en este bloque Como resultado, de este ejemplo, la variable externa siempre ser√° nula.\nSoluci√≥n:\nLa primera opci√≥n es usar variables temporales en los bloques internos:\nvar client *http.Client if tracing { c, err := createClientWithTracing() if err != nil { return err } client = c } else { // Same logic } 1 Crear una variable temporal c 2 Asignar esta variable temporal a client Otra opci√≥n es usar el operador de asignaci√≥n (=) en los bloques internos para asignar directamente los resultados de la funci√≥n a la variable. Sin embargo, requiere crear una variable de error ya que el operador de asignaci√≥n solo funciona si ya se ha declarado un nombre de variable:\nvar client *http.Client var err error if tracing { client, err = createClientWithTracing() if err != nil { return err } } else { // Same logic } 1 Declarar una variable de error 2 Usar operador de asignaci√≥n para asignar el *http.Client devuelto a la variable client directamente - C√≥digo anidado innecesario Un aspecto cr√≠tico de la legibilidad es el n√∫mero de niveles anidados. Un c√≥digo se califica como legible en funci√≥n de m√∫ltiples criterios, como el nombrado, la consistencia, el formato, etc. Un c√≥digo legible requerir√° menos esfuerzo cognitivo para mantener un modelo mental; por lo tanto, ser√° m√°s f√°cil de leer y mantener.\nEjemplo:\nTiempo o dificultad para entender la siguiente funci√≥n a detalle.\nfunc join(s1, s2 string, max int) (string, error) { if s1 == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;s1 is empty\u0026#34;) } else { if s2 == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;s2 is empty\u0026#34;) } else { concat, err := concatenate(s1, s2) if err != nil { return \u0026#34;\u0026#34;, err } else { if len(concat) \u0026gt; max { return concat[:max], nil } else { return concat, nil } } } } } func concatenate(s1 string, s2 string) (string, error) { // ... } Soluci√≥n:\nHacer la tarea de aplicar legibilidad y consistencia sobre la misma funci√≥n, implementandola de manera diferente:\nfunc join(s1, s2 string, max int) (string, error) { if s1 == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;s1 is empty\u0026#34;) } if s2 == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;s2 is empty\u0026#34;) } concat, err := concatenate(s1, s2) if err != nil { return \u0026#34;\u0026#34;, err } if len(concat) \u0026gt; max { return concat[:max], nil } return concat, nil } func concatenate(s1 string, s2 string) (string, error) { // ... } El resultado para requerir menos carga cognitiva. - Mal uso de las funciones init En principio init es una funci√≥n que no toma argumentos y no devuelve ning√∫n resultado (una funci√≥n func()). Cuando se inicializa un paquete, se eval√∫an todas las declaraciones de constantes y variables del paquete. El principal problema reside cuando se ha creado un flujo de uso que se vuelve dificil de entender o seguir y por falta de entendimiento se provocan errores no manejados que se volveran dificiles de mitigar o controlar.\nEjemplo:\nOlvidar o no haber entendido el sentido o punto de entrada para ejecuion de init.\npackage main import \u0026#34;fmt\u0026#34; var a = func() int { fmt.Println(\u0026#34;var\u0026#34;) return 0 }() func init() { fmt.Println(\u0026#34;init\u0026#34;) } func main() { fmt.Println(\u0026#34;main\u0026#34;) } Salida\n1: var 2: init 3: main Ejemplo de flujo usando Redis en base de codigo personal.\nSoluci√≥n:\nHay criterios en sentido idiomatico como:\nEvitar incluir funciones init en codigo que sera probado con paquete de testing.\nNo hacer que sean de ambito global a menos que sea realmente requerido.\nEvitar usar para conexiones a base de datos.\nInvestigar situaciones en las que pueden ser √∫tiles, como definir una configuraci√≥n est√°tica. De lo contrario, y en la mayor√≠a de los casos, manejar las inicializaciones a trav√©s de funciones personalizadas.\nEbook recomendado: 100 Go Mistakes Que trata a fondo algunos errores sobre: Tipos de datos, Estructuras de control, Strings en detalle, Funciones y m√©todos, Manejo de errores, Concurrencia: Fundamentos y Pr√°ctica, Librer√≠a est√°ndar, Pruebas y Optimizaciones\n"},{"href":"https://gophers-latam.github.io/posts/2021/12/ecosistema-lenguage-go/","title":"Ecosistema lenguage Go","body":" json to go Go, tambi√©n conocido como Golang, es un lenguaje de programaci√≥n de tipado est√°tico desarrollado por Robert Griesemer, Rob Pike y Ken Thompson en Google.\nGo es sint√°cticamente similar a C, pero viene con seguridad de memoria, recolecci√≥n de basura, tipificaci√≥n estructural y sincronizaci√≥n al estilo CSP.\nHay dos implementaciones principales:\nEl paquete de alojamiento de Google que se dirige a m√∫ltiples sistemas operativos, dispositivos m√≥viles y WebAssembly.\ngccgo (un front) y GCC\nGo es expresivo, conciso, limpio y eficiente. Los mecanismos simult√°neos facilitan la escritura de aplicaciones que aprovechan al m√°ximo las m√°quinas en red de varios n√∫cleos, mientras que el sistema m√°s nuevo permite crear aplicaciones modulares y flexibles. Compila c√≥digo m√°quina con bastante rapidez, pero tiene la conveniencia de la recolecci√≥n de basura y el poder de reflejar el tiempo de ejecuci√≥n. - Un lenguaje r√°pido, bien tipado y bien proporcionado que act√∫a como un lenguaje interpretado din√°mico.\nNada hace que un programador se emocione m√°s que descubrir un nuevo lenguaje de programaci√≥n. Al examinar el estado actual del software y hardware inform√°tico, podemos ver por qu√© tenemos que cambiar a un nuevo lenguaje como Go. Durante la √∫ltima d√©cada, la potencia de procesamiento en bruto ha aumentado ligeramente y el rendimiento de la frecuencia de la CPU se ha mantenido casi constante durante una d√©cada.\nGo, se libero cuando los procesadores de varios n√∫cleos ya estaban disponibles. Es por eso que Go se hizo pensando en la coordinaci√≥n. Sus mecanismos s√≠ncronos facilitan la escritura de aplicaciones que utilizan m√°s sistemas multin√∫cleo y en red. Si bien el nuevo tipo de sistema Go hace posible construir aplicaciones modulares flexibles, en lugar de centrarse en teor√≠as, en m√©todos del mundo real para construir aplicaciones de pr√≥xima generaci√≥n en la nube, as√≠ como computaci√≥n avanzada y computaci√≥n distribuidas.\nHist√≥rico Go es un lenguaje de programaci√≥n procedimental que se lanz√≥ en 2009 como lenguaje de programaci√≥n de c√≥digo abierto. Actualmente se utiliza en varios sistemas operativos de Google. El Go Compiler es compatible con Linux, Mac OS, Windows y una variedad de sistemas operativos BSD como FreeBSD. En t√©rminos de arquitectura de procesador, la arquitectura X86, la arquitectura X64, la arquitectura ARM y la arquitectura Power espec√≠fica de IBM tambi√©n son compatibles con Go.\nArquitectura Ling√º√≠stica Go tiene muchas herramientas poderosas de an√°lisis est√°tico. Uno de ellos es go fmt, que dise√±a su c√≥digo bas√°ndose en el estilo Go propuesto. Esto puede eliminar muchos comentarios en un proyecto normal y alentar a su equipo a concentrarse en el c√≥digo. Lenguaje de programaci√≥n desarrollado y compilado de forma nativa, que pertenece principalmente a la familia de lenguajes C en t√©rminos de sintaxis b√°sica.\nComo C y C++, est√° compilado en c√≥digo de m√°quina, por lo que no necesitamos entornos como CLR y JVM para ejecutar programas Go. Esto ayuda especialmente al compilar programas grandes. Lenguaje simple y minimalista con dise√±o original de Go para en lugar del cl√°sico Thread a goroutines. En Go, el l√≠mite de tama√±o de pila m√≠nimo se elimina de 4 KB a 8 KB cuando se crea una goroutine.\nDise√±o Go est√° influenciado por C, pero con un mayor √©nfasis en la simplicidad y la seguridad. Esto incluye:\nPatrones de adopci√≥n de sintaxis y entorno que son m√°s comunes en lenguajes din√°micos: Declaraci√≥n de variable corta opcional e introducci√≥n inicial por inferencia de tipo.\nEdici√≥n r√°pida.\nAdministraci√≥n de paquetes remotos (go download) y documentaci√≥n de paquetes en l√≠nea.\nEnfoques distintivos para problemas espec√≠ficos.\nSincronizaci√≥n inicial: procesos de estilo (Gurvin), canales y expresiones selectivas.\nUn sistema de interfaz en lugar de herencia virtual e incrustaci√≥n de tipo en lugar de la herencia no virtual.\nUn kit de herramientas que, de forma predeterminada, crea binarios de interfaz nativa sin dependencias externas.\nLa tendencia a preservar las propiedades del lenguaje es lo suficientemente simple como para mantener en calam la cabeza de un programador, en parte eliminando caracter√≠sticas que son comunes a lenguajes similares.\nGo es Back o Front? El c√≥digo Go se puede ejecutar usando goper.js en el navegador. Pero el hecho es que la mayor√≠a de los desarrolladores recurren a los lenguajes de programaci√≥n Front y JavaScript para desarrollar su lado del cliente. Go es m√°s preferido como lenguaje de respaldo y ofrece un alto rendimiento para el desarrollo simult√°neo de aplicaciones de servidor.\nAlgunas aplicaciones populares desarrolladas en Go Algunos de los proyectos de c√≥digo abierto en Go son:\nCaddy: servidor web HTTP 2 de c√≥digo abierto con capacidad HTTPS autom√°tica\nCockroachDB: una base de datos SQL de c√≥digo abierto, escalable y compatible\nDocker: incluye un conjunto de herramientas de implementaci√≥n de Linux.\nEthereum: implementaci√≥n de Go-Ethereum, m√°quina de bloqueo de m√°quina virtual, Ethereum virtual para criptomoneda Ether\nHugo: un generador de sitios est√°ticos\nInfluxDB: base de datos de c√≥digo abierto para series de datos de alto acceso con requisitos de alto rendimiento\nInterPlanetary File System: un contenido y un protocolo de direccionamiento de medios punto a punto.\nJuju: una herramienta de evaluaci√≥n de servicios de Canonical, paquetes de Ubuntu Linux.\nKubernetes: sistema de gesti√≥n de contenedores\nLightning Network: una red de bitcoins para transacciones r√°pidas de bitcoins.\nMattermost: un sistema de chat en equipo.\nOpenShift: una plataforma de computaci√≥n en la nube proporcionada por Red Hat como servicio.\nSnappy: un administrador de paquetes para Ubuntu Touch desarrollado por Canonical.\nSyncthing: software de sincronizaci√≥n de archivos cliente/servidor de c√≥digo abierto.\nTerraform: una herramienta de c√≥digo abierto para la infraestructura multimedia en la nube proporcionada por HashiCorp.\nEmpresas y sitios notables que han utilizado GO (generalmente junto con otros lenguajes, no exclusivamente) Cacoo: para renderizar paneles de usuario y microservicios usando Go y gRPC.\nChango: una empresa de publicidad que utiliza sistemas de precios en tiempo real.\nCloud Foundry: una plataforma como servicio.\nCloudFlare: se utiliza para el proxy de codificaci√≥n Delta Railgun, su servicio de DNS distribuido, as√≠ como herramientas para encriptaci√≥n, registro, procesamiento de flujo y acceso a sitios SPDY.\nCoreOS: un sistema operativo basado en Linux que utiliza el repositorio Docker y el repositorio rkt.\nDropbox: que ha migrado algunos de sus componentes vitales de Python a Go.\nEthereum: una moneda digital\nGoogle: se utiliza para muchos proyectos, incluido el servidor de descargas (dl.google.com).\nHyperledger Fabric: un proyecto de c√≥digo abierto √∫nico.\nMongoDB: una herramienta para administrar instancias de MongoDB\nNetflix: se utiliza para dos partes de la arquitectura de su servidor.\nNovartis: para sistema de inventario interno\nNutanix: se utiliza para una variedad de microservicios en su empresa Cloud OS.\nPlug.dj: un sitio web interactivo relacionado con la transmisi√≥n de m√∫sica social en l√≠nea.\nSendGrid: un boulder, servicio de entrega de correo electr√≥nico y servicio de gesti√≥n de transacciones.\nSoundCloud: se utiliza para \u0026ldquo;docenas de sistemas\u0026rdquo;.\nEmpalme: se utiliza para todo el backend (API y analizadores) en su plataforma de colaboraci√≥n musical en l√≠nea.\nThoughtWorks: Algunas herramientas y aplicaciones para entrega continua y mensajer√≠a instant√°nea (CoyIM).\nTwitch.tv: para el sistema de chat basado en IRC (migraci√≥n desde Python).\nUber: para manejar grandes vol√∫menes de consultas basadas en geovallas\nGo Features Go compila c√≥digo como lenguajes de bajo nivel como C++/C. Esto significa que funciona casi tan bien como lenguajes de bajo nivel. Tambi√©n utiliza la recolecci√≥n de basura para recolectar y eliminar objetos.\nEl gr√°fico siguente muestra que Go es casi tan eficiente como C++/C, mientras mantiene la sintaxis simple como Ruby, Python y otros lenguajes. Esta es una situaci√≥n en la que todos ganan para los humanos y los procesadores! El alto rendimiento como C++/C y Java proporciona una sincronizaci√≥n altamente eficiente para codificar en t√©rminos divertidos como Python y Perl. El software optimizado puede ejecutarse en hardware m√°s barato y lento, como los dispositivos IoT, y generalmente tiene un mayor impacto en la experiencia del usuario final. El modelo de memoria Go agrega una nueva regla para enviar y recibir canales de b√∫fer para indicar expl√≠citamente que un canal de b√∫fer puede usarse como un simple spammer.\nDescripci√≥n general de las caracter√≠sticas principales del lenguaje:\nCompilaci√≥n: Go genera compilaciones binarias para sus aplicaciones con todas las dependencias. No se requiere instalaci√≥n de traductor o runtime.\nRecolecci√≥n de basura: Para recolectar desperdicios de baja latencia, opta por una administraci√≥n autom√°tica de memoria que sea eficiente y sincr√≥nica. La gesti√≥n de la memoria es intencionadamente m√°s f√°cil que C y C++. Los objetos dedicados recolectan basura de forma din√°mica.\nSeguro: Go es un lenguaje de tipado est√°tico que admite la seguridad de tipos. El compilador detecta los errores antes de la ejecuci√≥n.\nSintaxis similar a C: La sintaxis Go recuerda a la familia C, pero con solo 25 palabras clave simples, es f√°cil de analizar sin tablas/s√≠mbolos de informaci√≥n de tipo y un dise√±o de notificaci√≥n similar a Pascal.\nVarios paradigmas: Go admite varios patrones de programaci√≥n, incluida la programaci√≥n esencial, orientada a objetos (OOP) y la programaci√≥n funcional.\nLibrer√≠a est√°ndar: Go tiene una potente librer√≠a est√°ndar de paquetes para respaldar el desarrollo de aplicaciones Go.\nDocumentaci√≥n sencilla: GoDoc es una herramienta de an√°lisis de c√≥digo est√°tico que genera documentos est√°ndar simplificados directamente desde el c√≥digo.\nSoporte de pruebas naturalmente: Soporte de prueba integrado en la librer√≠a est√°ndar. Sin necesidad de dependencia adicional Si tiene un archivo llamado thing.go, escriba sus pruebas en otro archivo llamado thing_test.go y ejecute \u0026ldquo;go test\u0026rdquo;.\nGo Tools La distribuci√≥n principal de Go incluye herramientas para crear, probar y analizar c√≥digo:\ngo build: crea un binario usando solo sus archivos fuente.\ngo test: se utiliza para pruebas unitarias y microbenchmarks.\ngo fmt: se utiliza para formatear el c√≥digo.\ngo get: se utiliza para recuperar e instalar paquetes remotos.\ngo vet: un analizador est√°tico que busca posibles vulnerabilidades o errores en el c√≥digo.\ngo run: un atajo para construir y ejecutar c√≥digo directamente.\ngo doc: para mostrar documentos o enviarlos a trav√©s de HTTP\ngo rename: se utiliza para renombrar variables, funciones, etc. en tipo seguro.\ngo generate: un m√©todo est√°ndar para llamar a un generador de c√≥digo\nTambi√©n incluye soporte de depuraci√≥n y perfiles, herramientas de medici√≥n de tiempo de ejecuci√≥n. El ecosistema de herramientas de terceros se ha agregado a la distribuci√≥n est√°ndar, incluido gocode, que permite completar autom√°ticamente el c√≥digo en muchos editores de texto. goimports (por un miembro del equipo de Go) que autom√°ticamente elimina o agrega paquetes seg√∫n sea necesario, y errcheck, que detecta errores de c√≥digo y puede ignorarlos. Hay complementos para agregar soporte de idioma en algunos editores de texto. Hay varios IDE disponibles, incluidos LiteIDE y el \u0026ldquo;Go IDE multiplataforma\u0026rdquo; y GoLand.\nAplicaciones del lenguaje Go est√° dise√±ado espec√≠ficamente como lenguaje de programaci√≥n para grandes sistemas distribuidos y servidores de red altamente escalables. En este sentido, reemplaza a C++ y Java en la pila de software de Google. Muchos equipos buscan crear nuevos servidores en Go. Algunos incluso est√°n migrando bases de c√≥digo existentes. Algunas de las tecnolog√≠as de Google que utiliza a diario tienen componentes escritos en Go.\nDado que este es un lenguaje de programaci√≥n relativamente nuevo, muchos preguntan para qu√© es adecuado.\nUn vistazo a algunos de sus beneficios:\nIdeal para el desarrollo web\nExcelente para scripts de l√≠nea de comandos\nSe puede utilizar para aplicaciones de servidor de red.\nSe puede utilizar para el desarrollo de front-end.\nLos desarrolladores disfrutan usando Go porque tiene un entorno de desarrollo completo, y aprender Go es muy f√°cil, incluso para desarrolladores sin experiencia. Una de las razones de esto se debe al gran ecosistema de herramientas, por lo que es muy √∫til para proyectos grandes y conjuntos. Esto lo convierte en una excelente opci√≥n para programar software propietario. Si se est√° buscando m√°s beneficios, Go fue creado y es mantenido por Google, que tiene una de las infraestructuras de nube m√°s importantes del mundo y puede ser a gran escala.\nData Science Es una ciencia multidisciplinaria que utiliza m√©todos, procesos, algoritmos y sistemas cient√≠ficos para extraer conocimientos e ideas de datos estructurados y no estructurados. La ciencia de datos es el concepto de combinar estad√≠sticas, an√°lisis de datos, aprendizaje autom√°tico y m√©todos relacionados para comprender y analizar fen√≥menos reales con datos. Extrae t√©cnicas y teor√≠as que han surgido de muchos campos de las matem√°ticas, la estad√≠stica, la inform√°tica y la ciencia de la informaci√≥n. El ganador del premio Turing, Jim Gray, ve la ciencia de datos como el \u0026ldquo;cuarto modelo\u0026rdquo; de la ciencia (experimental, te√≥rico, computacional y ahora basado en datos) y afirma que \u0026ldquo;todo lo relacionado con la ciencia est√° cambiando debido al impacto de la tecnolog√≠a de la informaci√≥n\u0026rdquo;.\nEn la actualidad, a menudo se usa indistintamente con conceptos anteriores, como an√°lisis empresarial, inteligencia empresarial, modelado de previsi√≥n y estad√≠sticas. Si bien muchos programas acad√©micos ahora tienen un t√≠tulo en ciencia de datos, no existe un consenso sobre la definici√≥n del contenido curricular apropiado. Sin embargo, muchos proyectos de ciencia de datos y Big Data no han podido lograr resultados √∫tiles, a menudo debido a la falta de gesti√≥n y utilizaci√≥n de recursos.\n¬´ Go demuestra cada vez pruebas m√°s r√°pidas, codificaci√≥n f√°cil en lenguajes de programaci√≥n concurrentes altamente eficientes. Por lo general, es la pr√≥xima generaci√≥n de ciencia de datos, aprendizaje autom√°tico e inteligencia artificial, porque existe un gran equilibrio entre la productividad y la retenci√≥n de c√≥digo. Muchos prototipos de cient√≠ficos de datos, que luego son transferidos a producci√≥n por otra persona, deja que Go haga ambas cosas. ¬ª\n"},{"href":"https://gophers-latam.github.io/posts/2021/08/go-talks/","title":"Go Talks","body":" talks Este post contiene charlas de Go que se pueden leer siguiendo los vinculos de cada t√≠tulo listado.\n2019 playground-v3.slide: Playground v3 2017 state-of-go-may.slide\nexporting-go\nstate-of-go-aug\n2016 refactor.article: Codebase Refactoring (with help from Go)\napplicative.slide: Program your next server in Go\nasm.slide: The Design of the Go Assembler\nstate-of-go.slide: The State of Go\ntoken.slide: Stacks of Tokens\nprototype-your-design\n2015 dynamic-tools.slide: Go Dynamic Tools\ngo-for-java-programmers.slide: Go for Java Programmers\ngo4cpp.slide: Go for C++ developers\ngofmt-cn.slide: gofmt ÁöÑÊñáÂåñÊºîÂèò\ngofmt-en.slide: The Cultural Evolution of gofmt\ngogo.slide: Go in Go\ngophercon-go-on-mobile.slide: Go on Mobile\ngophercon-goevolution.slide: The Evolution of Go\ngotham-grpc.slide: gRPC Go\nhow-go-was-made.slide: How Go was made\njson.slide: JSON, interfaces, and go generate\nkeeping-up.slide: Keeping up with the Gophers\nsimplicity-is-complicated.slide: Simplicity is Complicated\nstate-of-go.slide: The State of Go\ntricks.slide: Stupid Gopher Tricks\n2014 c2go.slide: Go, from C to Go\ncamlistore.slide: - Camlistore: Android, ARM, App Engine, anywhere.\ncompiling.slide: - Go: Easy to Read, Hard to Compile\ndroidcon.slide: Go on Android\ngo1.3.slide: Toward Go 1.3\ngo4gophers.slide: Go for gophers\ngo4java.slide: Go for Javaneros (Java√Østes?)\ngocon-tokyo.slide: - Go: 90% Perfect, 100% of the time.\ngotham-context.slide: Cancelation, Context, and Plumbing\ngothamgo-android.slide: Go on Android\nhammers.slide: Gophers With Hammers\nhellogophers.slide: Hello, Gophers!\nnames.slide: What\u0026rsquo;s in a name?\norganizeio.slide: Organizing Go code\nplayground.slide: Inside the Go playground\nreadability.slide: When in Go, do as Gophers do\nresearch.slide: The Research Problems of Implementing Go\nresearch2.slide: More Research Problems of Implementing Go\nstate-of-go.slide: The State of Go\nstate-of-the-gopher.slide: The State of the Gopher (Oct)\nstatic-analysis.slide: Static analysis tools\ntaste.slide: A Taste of Go\ntesting.slide: Testing Techniques\n2013 advconc.slide: Advanced Go Concurrency Patterns\nbestpractices.slide: Twelve Go Best Practices\ndistsys.slide: Go, for Distributed Systems\ngo-sreops.slide: Go Language for Ops and Site Reliability Engineering\ngo1.1.slide: What\u0026rsquo;s new in Go 1.1\ngo4python.slide: Go for Pythonistas\nhighperf.slide: High Performance Apps with Go on App Engine\noscon-dl.slide: dl.google.com: Powered by Go\n2012 10things.slide: 10 things you (probably) don\u0026rsquo;t know about Go\nchat.slide: - Go: code that grows with grace\nconcurrency.slide: Go Concurrency Patterns\ngo-docs.slide: Go docs\ngo1.slide: The Path to Go 1\ngoforc.slide: Go for C programmers\ninsidepresent.slide: Inside the \u0026ldquo;present\u0026rdquo; tool\nsimple.slide: - Go: a simple programming environment\nsplash.slide: Go at Google\ntutorial.slide: Get started with Go\nwaza.slide: Concurrency is not Parallelism\nzen.slide: Go and the Zen of Python\n2011 lex.slide: Lexical Scanning in Go 2010 ExpressivenessOfGo-2010\ngo_talk-20100112\ngo_talk-20100121\ngo_talk-20100323\ngofrontend-gcc-summit-2010\n2009 go_talk-20091030 "},{"href":"https://gophers-latam.github.io/posts/2021/06/conversi%C3%B3n-json-a-go/","title":"Conversi√≥n JSON a Go","body":" json to go Uno de los formatos de datos que se encuentra con mucha frecuencia en programaci√≥n, principalmente web, es JavaScript Object Notation (JSON).\nCuando se recibe datos en formato JSON de representaci√≥n, debe convertirse a un formato que sea f√°cil de manipular en el programa en Go. Hay algunas herramientas en l√≠nea que permiten convertir fuente JSON directamente en estructuras Go, aunque haciendo una simple b√∫squeda google.com/search?q=json+to+go se ve varidad de resultados, las destacadas o pioneras son:\nJSON-to-Go - mholt.github.io/json-to-go/\nTransform - transform.tools/json-to-go\nJson2Struct - json2struct.mervine.net/\nPor √∫ltimo como extensi√≥n de navegador para mejor accesibilidad existe json to go para Chrome.\n"},{"href":"https://gophers-latam.github.io/posts/2021/05/golang-implementaci%C3%B3n-del-almacenamiento-en-cach%C3%A9/","title":"Golang: Implementaci√≥n del almacenamiento en cach√©","body":" go cache El almacenamiento en cach√© de datos en una aplicaci√≥n web a veces es necesario para evitar solicitar datos est√°ticos de una base de datos o un servicio externo una y otra vez. Go no proporciona ning√∫n paquete integrado en la librer√≠a est√°ndar para almacenar en cach√© las respuestas, pero lo admite a trav√©s de paquetes externos creados por la comunidad.\nHay una serie de paquetes, como github.com/coocood/freecache,¬†github.com/patrickmn/go-cache, github.com/eko/gocache y github.com/etcd-io/etcd (gRPC) que pueden ayudar a implementar el almacenamiento en cach√©. Por parte de la comunidad de Gophers LATAM se busca crear algo relacionado: github.com/gophers-latam/GoKey\nPara este post se estar√° usando github.com/patrickmn/go-cache para implementar un ejemplo de uso.\nEjemplo: Primero crear un directorio para el c√≥digo fuente de prueba e inicializar un go module. [go mod init cache-example]\nLuego crear archivo .go, donde se har√° un cach√© por medio de la librer√≠a y se completar√° con datos sobre el arranque del servidor, de la siguiente manera:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/patrickmn/go-cache\u0026#34; ) const ( CONN_PORT = \u0026#34;8080\u0026#34; ) var newCache *cache.Cache func init() { newCache = cache.New(5*time.Minute, 10*time.Minute) newCache.Set(\u0026#34;gophers\u0026#34;, \u0026#34;gophers latam\u0026#34;, cache.DefaultExpiration) } func getFromCache(w http.ResponseWriter, r *http.Request) { gophers, found := newCache.Get(\u0026#34;gophers\u0026#34;) if found { log.Print(\u0026#34;Key encontrada en cach√© con valor, como : \u0026#34;, gophers.(string)) fmt.Fprintf(w, \u0026#34;Hola \u0026#34;+gophers.(string)) } else { log.Print(\u0026#34;Key no encontrada en cach√© : \u0026#34;, \u0026#34;gophers\u0026#34;) fmt.Fprintf(w, \u0026#34;Key no encontrada en cach√©\u0026#34;) } } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, getFromCache) err := http.ListenAndServe(\u0026#34;:\u0026#34;+CONN_PORT, nil) if err != nil { log.Fatal(\u0026#34;error al iniciar el servidor http : \u0026#34;, err) return } } Ejecutar el c√≥digo. Como funciona: Una vez iniciado, el servidor HTTP comenzar√° a escuchar localmente en el puerto 8080. Al inicio, la clave con el nombre gophers con un valor como gophers latam se agregar√° a la cach√©.\nAl navegar por http://localhost:8080/ se leer√° un valor de key de la cach√© y lo agregar√° a Hola como se muestra en la siguiente captura de pantalla:\nLog en terminal:\nSe ha especificado el tiempo de caducidad de los datos de la cach√© en el programa como 5 minutos, lo que significa que la clave que se ha creado en la cach√© al iniciar el servidor no estar√° all√≠ despu√©s de 5 minutos. Por lo tanto, acceder a la misma URL nuevamente despu√©s de 5 minutos devolver√° que la clave no es encontrada en la cach√© del servidor, de la siguiente manera:\nUsando var newCache *cache.Cache, se declara una cach√© privada.\nSe actualiza la funci√≥n init() donde se crea un cach√© con 5 minutos de tiempo de vencimiento y 10 minutos de intervalo de limpieza, y se agrega un elemento a cach√© con una clave como gophers con su valor como gophers latam y su valor de vencimiento como 0, lo que significa que se quiere usar el tiempo de vencimiento predeterminado de la cach√©.\nPara usarse se define el controlador getFromCache donde se recupera el valor de una clave en cach√©. Si se encuentra, se escribe en respuesta HTTP, de lo contrario, se escribe el mensaje Key no encontrada en cach√©.\n"},{"href":"https://gophers-latam.github.io/posts/2021/05/golang-init-func/","title":"Golang: Init func","body":" init func Cada programa en Go debe tener un paquete main con una funci√≥n main para ser ejecutado. Sin embargo, esto impone algunas limitaciones para determinadas soluciones, como las librer√≠as. Imagina que importamos una librer√≠a a nuestro c√≥digo.\nUna librer√≠a no est√° dise√±ada para ser ejecutada, ofrece estructuras de datos, m√©todos, funciones, etc. Es probable que las librer√≠as ni siquiera tengan un paquete main. Si esta librer√≠a requiere alguna configuraci√≥n inicial antes de ser invocada (inicializar variables, detectar el sistema operativo, etc.) parece imposible.\nGo define las funciones init que se ejecutan una vez por paquete. Cuando importamos un paquete, el tiempo de ejecuci√≥n (runtime) de Go sigue este orden:\nInicializar los paquetes importados de forma recursiva. Inicializar y asignar valores a las variables. Ejecutar las funciones de init. Ejemplos: 1. - En el resultado para el c√≥digo de ejemplo se muestra c√≥mo la inicializaci√≥n sigue el orden descrito anteriormente. La funci√≥n xSetter se invoca primero, seguida de init y la funci√≥n main.\npackage main import \u0026#34;fmt\u0026#34; var x = xSetter() func xSetter() int { fmt.Println(\u0026#34;xSetter\u0026#34;) return 42 } func init() { fmt.Println(\u0026#34;Init function\u0026#34;) } func main() { fmt.Println(\u0026#34;Este es el main\u0026#34;) } Salida en ejecuci√≥n: La funci√≥n init no tiene argumentos ni devuelve ning√∫n valor. Un paquete puede tener varias funciones init y no se pueden invocar desde ninguna parte del c√≥digo.\nGo no permite importar un paquete si no se usa dentro del c√≥digo. Sin embargo, es posible que solo nos interese ejecutar las funciones init de un paquete. Esto es lo que Go llama los efectos secundarios de un paquete (side effects pkg). Por lo general, esto se hace en paquetes que realizan alguna operaci√≥n de arranque o registro. La instrucci√≥n especial import _¬†solo llama a las funciones init de un paquete que no requiere su uso dentro del c√≥digo.\n2. - Ejemplo usando import _ :¬†importado el paquete \u0026ldquo;a\u0026rdquo; para utilizar sus efectos secundarios. Observar que este paquete tiene dos funciones init que se ejecutan antes del init del paquete de importaci√≥n. [go mod init ejemplo2]\nejemplo2/main.go\npackage main import ( \u0026#34;fmt\u0026#34; _ \u0026#34;ejemplo2/a\u0026#34; ) func init() { fmt.Println(\u0026#34;Init desde mi programa\u0026#34;) } func main() { fmt.Println(\u0026#34;Mi programa\u0026#34;) } ejemplo2/a/a.go\npackage a import \u0026#34;fmt\u0026#34; func init() { fmt.Println(\u0026#34;Init 1 desde paquete a\u0026#34;) } func init() { fmt.Println(\u0026#34;Init 2 desde paquete a\u0026#34;) } Salida en ejecuci√≥n: "},{"href":"https://gophers-latam.github.io/posts/2021/04/golang-referencia-esencial-go-modules/","title":"Golang: Referencia esencial Go modules","body":" Go Modules Esta es una hoja de trucos esenciales, no una referencia oficial. Con el fin de que sea conciso, se omitieron aspectos menos frecuentes, dado que este sitio desde su repositorio esta abierto a cambios de contribuidores en la comunidad de Gophers LATAM cualquiera puede hacer cambios que mejoren este contenido.\nInicio r√°pido Gesti√≥n de dependencias go get -d github.com/path/to/module # agregar o actualizar dep (-v log verboso) go get -d github.com/dep/two/v2@v2.1.0 # usar una versi√≥n espec√≠fica go get -d github.com/dep/commit@branch # usar una rama espec√≠fica go get -d -u ./... # actualizar m√≥dulos utilizados en subdirectorios go get -d github.com/dep/legacy@none # eliminar dep Comandos √∫tiles go mod tidy # organizar y limpiar go.mod and go.sum go mod download # descargar deps en cach√© de m√≥dulos go mod init github.com/path/to/module # inicializar nuevo m√≥dulo go mod why -m github.com/path/to/module # por qu√© el m√≥dulo es una dependencia? go install github.com/path/to/bin@latest # construir e instalar binario Anatom√≠a del go.mod // ruta de importaci√≥n de Go con lugar donde se aloja el m√≥dulo module github.com/my/library go 1.16 // versi√≥n utilizada para desarrollar m√≥dulo (usar nuevas funciones de lenguaje) require ( github.com/dep/one v1.0.0 // v2 y posteriores tienen versi√≥n principal en ruta del m√≥dulo github.com/dep/two/v2 v2.3.0 // \u0026#34;pseudo-versi√≥n\u0026#34; que se refiere a un commit y no a una versi√≥n etiquetada. github.com/dep/other v0.0.0-20180523231146-b3f5c0f6e5f1 github.com/dep/legacy v2.0.0+incompatible // \u0026#34;incompatible\u0026#34; significa que el paquete a√∫n no se ha migrado a nuevos m√≥dulos de Go ) exclude github.com/dep/legacy v1.9.2 // evitar que se use una versi√≥n de m√≥dulo espec√≠fica replace github.com/dep/one =\u0026gt; github.com/fork/one // reemplazar este m√≥dulo con este otro Selecci√≥n de versi√≥n m√≠nima (MVS) Para crear un programa, Go necesita saber exactamente qu√© dependencias necesita y qu√© versi√≥n usar.\nGo utiliza MVS como una forma sencilla y predecible de decidir qu√© versi√≥n utilizar.\nFunciona as√≠:\nEl m√≥dulo desde el que est√° ejecutando es el \u0026ldquo;m√≥dulo main\u0026rdquo;\nEncuentra todas las dependencias que necesita el m√≥dulo principal (de forma recursiva, usando los archivos go.mod de las dependencias)\nPara cada dependencia, usar la mayor versi√≥n que cualquier go.mod haya especificado expl√≠citamente\nEjemplo: En este ejemplo, el m√≥dulo principal depende de A 1.0 y B 2.1.\nDado que B 2.1 depende de A 1.1, esta es la versi√≥n de A que se utilizar√°.\nDado que se usa A 1.1, tambi√©n en C 1.1.\nLa lista final de dependencias es:\nA 1.1 B 2.1 C 1.1 Fuentes: Referencia oficial: https://golang.org/ref/mod\nVersi√≥n del post original: https://encore.dev/guide/go.mod\n"},{"href":"https://gophers-latam.github.io/posts/2021/04/golang-la-interfaz-vac%C3%ADa/","title":"Golang: La interfaz vac√≠a","body":" Interface type Explicaci√≥n breve sobre el tipo interfaz vacia y nula.\nSe define una interfaz vac√≠a como interface{}, y puede contener un valor de cualquier tipo:\nvar i interface{} i = \u0026#34;hola gophers\u0026#34; fmt.Println(i) Si se necesita probar si una interfaz es de cierto tipo, se usa una aserci√≥n de tipo:\nvar i interface{} i = \u0026#34;hola gophers\u0026#34; s, ok := i.(string) if !ok { fmt.Println(\u0026#34;s is not type string\u0026#34;) } fmt.Println(s) En el ejemplo anterior, i es un tipo string, por lo que el segundo valor de retorno de la aserci√≥n de tipo es verdadero (ok) y s contiene el valor por debajo de este. Si hubiera sido de otro tipo, como un int, entonces el ok habr√≠a sido falso y s habr√≠a sido el valor cero del tipo que se estaba tratando de afirmar, es decir, 0.\nInterfaz nula Una interfaz en Go es esencialmente una tupla que contiene el tipo y el valor subyacentes. Para que una interfaz se considere nula, tanto el tipo como el valor deben ser nulos (nil). Ejemplo:\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { var i interface{} fmt.Println(i == nil) fmt.Printf(\u0026#34;%T, %v\\n\u0026#34;, i, i) var s *string fmt.Println(\u0026#34;s == nil:\u0026#34;, s == nil) i = s fmt.Println(\u0026#34;i == nil:\u0026#34;, i == nil) fmt.Printf(\u0026#34;%T, %v\\n\u0026#34;, i, i) Salida:\ntrue \u0026lt;nil\u0026gt;, \u0026lt;nil\u0026gt; s == nil: true i == nil: false *string, \u0026lt;nil\u0026gt; Observar que la variable s es nil, pero cuando se establece la interfaz i en s, se verifica si i es nil, i no se considera nil. Esto se debe a que la interfaz tiene un tipo concreto por debajo establecido y las interfaces solo son nulas cuando tanto el tipo concreto como el valor son nulos.\n"},{"href":"https://gophers-latam.github.io/search/","title":"B√∫squeda","body":""},{"href":"https://gophers-latam.github.io/posts/2021/04/golang-mantener-actualizado-el-sdk/","title":"Golang: Mantener actualizado el SDK","body":" Update Go Como ocurre con todos los lenguajes de programaci√≥n, hay actualizaciones peri√≥dicas de las herramientas de desarrollo de Go. El SDK Go son binarios nativos que no dependen de un tiempo de ejecuci√≥n independiente, por lo que no hay que preocuparse de que la actualizaci√≥n del entorno de desarrollo pueda hacer que los programas actualmente implementados fallen. Puede tenerse programas compilados con diferentes versiones de Go ejecut√°ndose simult√°neamente en la misma computadora o m√°quina virtual.\nDesde Go 1.2, ha habido una nueva versi√≥n importante aproximadamente cada seis meses. Tambi√©n hay versiones menores con correcciones de errores y seguridad que se publican seg√∫n sea necesario. Dados los r√°pidos ciclos de desarrollo y el compromiso del equipo de Go con la compatibilidad con versiones anteriores, las versiones de Go tienden a ser incrementales en lugar de expansivas. La promesa de compatibilidad de Go es una descripci√≥n detallada de c√≥mo el equipo de Go planea evitar romper el c√≥digo de Go. Dice que no habr√° cambios retr√≥grados en el lenguaje o la librer√≠a est√°ndar para cualquier versi√≥n de Go que comience con 1, a menos que el cambio sea necesario para un error o correcci√≥n de seguridad. Sin embargo, puede haber (y ha habido) cambios incompatibles con versiones anteriores en los indicadores o la funcionalidad de los comandos go.\nA pesar de estas garant√≠as de compatibilidad con versiones anteriores, los errores ocurren, por lo que es natural querer asegurarse de que una nueva versi√≥n no rompa los programas personales ya hechos. Una opci√≥n es instalar un entorno Go secundario. Por ejemplo, si actualmente se est√° ejecutando la versi√≥n 1.15.2 y se quiere probar la versi√≥n 1.16.3, debe usarse los siguientes comandos:\ngo get golang.org/dl/go.1.16.3 go1.16.3 download Luego se puede usar el comando go1.16.3 en lugar del comando go para ver si la versi√≥n 1.16.3 funciona para los programas ya hechos anteriormente con la nueva versi√≥n de Go:\ngo1.16.3 build Una vez que se haya validado que el c√≥digo funciona, puede eliminarse el entorno secundario buscando el GOROOT, elimin√°ndolo y luego eliminando el binario del directorio $GOPATH/bin. A continuaci√≥n, las indicaciones de c√≥mo hacerlo en Mac OS, Linux y BSD respectivamente:\ngo1.16.3 env GOROOT /Users/gobook/sdk/go1.16.3 rm -rf $(go1.16.3 env GOROOT) rm $(go env GOPATH)/bin/go1.16.3 Cuando se est√° listo para actualizar las herramientas de desarrollo de Go instaladas en la computadora, los usuarios de Mac y Windows tienen la ruta m√°s f√°cil. Aquellos que instalaron con brew o chocolatey pueden usar esas herramientas para actualizar. Aquellos que usaron los instaladores en golang.org/dl pueden descargar el √∫ltimo instalador, que elimina la versi√≥n anterior cuando se instala la nueva.\nLos usuarios de Linux y BSD en general deben descargar la √∫ltima versi√≥n, mover la versi√≥n anterior a un directorio de respaldo, expandir la nueva versi√≥n y luego eliminar la versi√≥n anterior, algo as√≠:\nmv /usr/local/go /usr/local/old-go tar -C /usr/local -xzf go1.16.3.linux-amd64.tar.gz rm -rf /usr/local/old-go Como nota final, igual en cada versi√≥n que sale en el canal del Discord #üì∞fuente-noticias se comparte autom√°ticamente del canal de Twitter oficial como obtener la nueva versi√≥n.\n"},{"href":"https://gophers-latam.github.io/posts/2021/04/golang-resumen-reglas/","title":"Golang: Resumen reglas","body":" Go Police El lenguaje de programaci√≥n Go fue creado para hacer el trabajo f√°cilmente.\nGo tiene conceptos similares a los lenguajes imperativos y el tipado est√°tico. Tambi√©n es r√°pido en la compilaci√≥n, r√°pido de ejecutar e implementar. Grande y complejo.\nEn este post, se explican conceptos b√°sicos de Go tratando algunos conceptos o reglas importantes.\nLos principales temas tratados son los siguientes:\nEscribir comentarios. Librer√≠as e importaci√≥n. Funciones. Tipos de datos. Valores de retorno con nombre. Variables y memoria. Control de sentencias. Generar funciones. Ejecuci√≥n diferida. Interfaces. M√∫ltiples entradas. Manejo de errores. Ejecuci√≥n simult√°nea. Escribir comentarios: Para escribir un comentario de una l√≠nea\n// comentario de una sola l√≠nea Escribir un comentario con m√°s de una l√≠nea\n/* comentario de multi-l√≠nea */ Librer√≠as e importaci√≥n: Cada archivo de c√≥digo fuente comienza con la palabra clave package. La palabra clave main se utiliza para identificar el archivo como un archivo operativo, no como una librer√≠a.\npackage main Para importar un paquete de la librer√≠a est√°ndar, terceros o personal al archivo, usamos la instrucci√≥n import de la siguiente manera:\nimport ( \u0026#34;fmt\u0026#34; // paquete en la librer√≠a est√°ndar \u0026#34;io/ioutil\u0026#34; // se aplican funciones de E/S m \u0026#34;math\u0026#34; // usando la letra m para acortar o hacer alias del nombre de la librer√≠a de funciones matem√°ticas \u0026#34;net/http\u0026#34; // web server \u0026#34;os\u0026#34; // funciones a nivel del sistema operativo, como el manejo de archivos \u0026#34;strconv\u0026#34; // conversiones de texto ) Funciones: Las funciones se definen mediante la palabra func seguida del nombre de la funci√≥n.\nLa funci√≥n main es privada y es la entrada al archivo ejecutable del programa (Go usa llaves ornamentadas {} para definir partes / bloques).\nfunc main() { // salida de texto en la unidad main en stdout (salida estandar) con Println de fmt (stdlib pkg) fmt.Println (\u0026#34;Hello world!\u0026#34;) // llamar a una funci√≥n del paquete actual beyondHello() } Las funciones necesitan par√©ntesis que reciben par√°metros, e incluso en ausencia de par√°metros, se requieren par√©ntesis.\nfunc beyondHello() { // declaraci√≥n de variable (la variable debe declararse antes de usarse) var x int // dar valor a la variable x = 3 // definici√≥n corta usando := incluye definici√≥n de variable, especificando su tipo y d√°ndole valor y := 4 // una funci√≥n que devuelve dos valores separados sum, prod := learnMultiple (x, y) // imprimir salida de forma sencilla y directa fmt.Println (\u0026#34;sum:\u0026#34;, sum, \u0026#34;prod:\u0026#34;, prod) learnTypes() } La definici√≥n de funci√≥n puede tener m√∫ltiples coeficientes y valores de retorno. Por ejemplo, learnMultiple toma los coeficientes x, y \u0026hellip; y devuelve dos valores de sum y prod de tipo Int.\nfunc learnMultiple (x, y int) (sum, prod int) { // separar los valores devueltos con una coma regular return x + y, x * y } Tipos de datos: func learnTypes() { // las declaraciones cortas generalmente cumplen el prop√≥sito deseado // definir una variable de texto usando comillas dobles str := \u0026#34;Learn Go!\u0026#34; // definir una variable de texto con comillas simples s2 := `A \u0026#34;raw\u0026#34; string literal can include line breaks.` // definir variable tipo runa que es otro nombre para el tipo int32 que contiene unicode g := \u0026#39;Œ£\u0026#39; // float f := 3.14195 // definici√≥n de n√∫mero complejo (Complex) c := 3 + 4i // definir variables usando var var u uint = 7 // n√∫mero natural (entero positivo) var pi float32 = 22. / 7 // un decimal de 32 bits // definici√≥n corta byte (es otro nombre para uint8) n := byte (\u0026#39;\\n\u0026#39;) // arrays tienen un tama√±o fijo, y son fijos en momento de compilaci√≥n // definir un array int de 4 elementos con un valor inicial de cero var a4 [4] int // definir un array de 3 elementos con valores 3, 1 y 5 a3 := [...] int {3, 1, 5} Go ofrece un tipo de datos llamado Slices. Los Slices entendibles como \u0026ldquo;rebanadas\u0026rdquo;, \u0026ldquo;porciones\u0026rdquo;, \u0026ldquo;segmentos\u0026rdquo; tienen un tama√±o din√°mico. Las matrices (array) y los segmentos (slice) tienen ventajas, pero los casos de uso de los segmentos son m√°s comunes. La siguiente instrucci√≥n define un segmento de tipo int\n// observar la diferencia entre el array y la declaraci√≥n del slice, donde cuando // el slice est√° definido no hay un n√∫mero que determine su tama√±o s3: = [] int {4, 5, 9} // definir un tipo int con cuatro elementos con valores cero s4: = make ([] int, 4) // solo definir, y no hay selecci√≥n var d2 [] [] float64 // m√©todo para convertir el tipo de texto en slice bs: = [] byte (\u0026#34;a slice\u0026#34;) Por la naturaleza de los slice din√°micos, es posible agregar nuevos elementos usando la funci√≥n append incorporada. Primero se pasa el slice al que queremos agregar y luego los elementos que queremos agregar.\ns := [] int {1, 2, 3} s = append (s, 4, 5, 6) // se imprimir√° un slice con el siguiente contenido [1 2 3 4 5 6] fmt.Println (s) Para agregar un slice a otro slice, pasamos los dos slices en la funci√≥n en lugar de pasar elementos individuales, y siguiendo el segundo slice con tres puntos.\ns = append (s, [] int {7, 8, 9} ...) // se imprimir√° un slice con el siguiente contenido [1 2 3 4 5 6 7 8 9] fmt.Println (s) La siguiente instrucci√≥n define las variables p y q como punteros en dos variables de tipo int que contienen dos valores devueltos por la funci√≥n learnMemory:\np, q := learnMemory() // tema de reglas por ver Cuando un asterisco precede a un cursor, significa el valor de la variable a la que se refiere el cursor, como en el siguiente ejemplo los valores de las dos variables devueltas por la funci√≥n learnMemory:\nfmt.Println (*p, *q) Los mapas (maps) en Go son arrays din√°micos y modificables que son similares al tipo de diccionario o hash en otros lenguajes.\n// aqu√≠ un mapa cuya clave es tipo texto y los valores de los elementos num√©ricos. m: = map [string] int {\u0026#34;three\u0026#34;: 3, \u0026#34;four\u0026#34;: 4} m [\u0026#34;one\u0026#34;] = 1 Las variables no utilizadas son errores. El subrayado, guion bajo, operador blanco o Blank Identifier de la siguiente manera hace usar la variable pero ignora valores al mismo tiempo:\n_, _, _, _, _, _, _, _, _, _ = str, s2, g, f, u, pi, n, a3, s4, bs Valores de retorno con nombre: A diferencia de otros lenguajes, las funciones pueden tener valores de retorno con nombre. Donde el nombre se devuelve al valor de la funci√≥n en la l√≠nea de la definici√≥n de la funci√≥n, esta caracter√≠stica permite regresar f√°cilmente desde cualquier punto de la funci√≥n adem√°s del uso de la palabra return solo sin mencionar nada despu√©s:\nfunc learnNamedReturns (x, y int) (z int) { z = x * y // aqu√≠ impl√≠citamente significa devolver el valor de la variable z return } Nota: El lenguaje Go se basa en gran medida en la recolecci√≥n de basura. Go tiene indicadores pero no c√°lculos (puede confundir un cursor vac√≠o, pero no puede aumentar el cursor). Tener cuidado con valores de retorno de nil pointer reference.\nVariables y memoria: Las variables p y q a continuaci√≥n son indicadores del tipo int y representan valores de retorno en la funci√≥n. Cuando se define, los cursores est√°n vac√≠os; sin embargo, el uso de la funci√≥n incorporada new hace que el valor de la variable num√©rica p se refiera a cero, y por lo tanto ocupa espacio en la memoria; es decir, p ya no est√° vac√≠o.\nfunc learnMemory() (p, q* int) { p = new(int) // definir un slice de 20 elementos como una sola unidad en la memoria. s := make([] int, 20) // dar valor a un elemento s[3] = 7 // definir una nueva variable local a nivel de funci√≥n r := -2 // devolver dos valores de la funci√≥n, que son direcciones de memoria // para las variables s y r, respectivamente. return \u0026amp;s[3], \u0026amp;r } func expensiveComputation() float64 { return m.Exp (10) } Control de sentencias Las sentencias condicionales requieren corchetes ornamentados y no requieren par√©ntesis.\nfunc learnFlowControl() { if true {fmt.Println (\u0026#34;told ya\u0026#34; ) } if false { // Rusters. } else { // Gophers. } Usar la instrucci√≥n switch si se necesita escribir m√°s de una secuencia condicional.\nx := 42.0 switch x { case 0: case 1: case 42: case 43: default: } Como sentencia condicional, la cl√°usula for no toma par√©ntesis. Las variables definidas en la cl√°usula for son visibles a nivel de la sentencia.\nfor x: = 0; x \u0026lt;3; x ++ { fmt.Println (\u0026#34;iteration\u0026#34;, x) } La instrucci√≥n for es la √∫nica instrucci√≥n de iteraci√≥n en el lenguaje Go y tiene otra formas, de la siguiente manera:\n// repetici√≥n infinita for { // break para detener la repetici√≥n break // continue para ir a la siguiente iteraci√≥n continue } Se puede utilizar el range para pasar elementos de array, slice, text string, map, channel.\nEl range de canal (channel) devuelve un valor, y dos valores cuando se usa en slice, array, text string, o map.\n// ejemplo: for key, value := range map [string] int {\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3} { // imprimir el valor de cada elemento del mapa fmt.Printf (\u0026#34;key =% s, value =% d \\n\u0026#34;, key, value) } Usar el gui√≥n bajo (_) contra valor de retorno en la clave si solo se desea el valor, de la siguiente manera:\nfor _, name: = range [] string {\u0026#34;Bob\u0026#34;, \u0026#34;Bill\u0026#34;, \u0026#34;Joe\u0026#34;} { fmt.Printf (\u0026#34;Hello,% s \\n\u0026#34;, name) } Se puede usar la declaraci√≥n corta con la sentencia condicional para que se defina una variable y luego se verifique en la sentencia de condici√≥n.\nPor ejemplo se define una variable y, se le da un valor y luego se coloca la condici√≥n de la sentencia para que est√©n separadas por un punto y coma.\nif y := expensiveComputation(); y \u0026gt; x { x = y } Se puede definir funciones an√≥nimas falsas directamente en el c√≥digo.\nxBig := func() bool { // x:= 42 que fue declarada antes donde de menciona la sentencia switch return x \u0026gt; 10000 } x = 99999 // la funci√≥n xBig ahora devuelve el valor verdadero fmt.Println (\u0026#34;xBig:\u0026#34;, xBig()) x = 1.3e3 // Despu√©s de modificar el valor de x a 1.3e3 que es igual a 1300 (es decir, mayor que 1000) // la funci√≥n xBig devuelve falso fmt.Println (\u0026#34;xBig:\u0026#34;, xBig()) Adem√°s de lo anterior, es posible definir funci√≥n fantasma y llamarla en la misma l√≠nea y pasarla a otra funci√≥n siempre que se llame directamente y el tipo de resultado sea consistente con lo esperado en el par√°metro de la funci√≥n.\nfmt.Println (\u0026#34;Add + double two numbers:\u0026#34;, func (a, b int) int { return (a + b) * 2 } (10, 2)) goto love love: learnFunctionFactory() // Una funci√≥n que devuelve una funci√≥n learnDefer() // Dormir learnInterfaces() // Trabajar con interfaces } Generar funciones Se puede tratar las funciones como objetos separados. Por ejemplo, crear una funci√≥n y el valor de retorno es otra.\nfunc learnFunctionFactory() { Los dos m√©todos siguientes para imprimir la oraci√≥n son iguales, pero el segundo m√©todo es m√°s claro, m√°s legible y com√∫n.\nfmt.Println(sentenceFactory (\u0026#34;summer\u0026#34;) (\u0026#34;A beautiful\u0026#34;, \u0026#34;day!\u0026#34;)) d: = sentenceFactory (\u0026#34;summer\u0026#34;) fmt.Println(d (\u0026#34;A beautiful\u0026#34;, \u0026#34;day!\u0026#34;)) fmt.Println(d (\u0026#34;A lazy\u0026#34;, \u0026#34;afternoon!\u0026#34;)) } Los decoradores se encuentran en algunos lenguajes de programaci√≥n y en el mismo concepto en Go para que poder pasar datos a funciones.\nfunc sentenceFactory(mystring string) func(before, after string) string { return func(before, after string) string { return fmt.Sprintf (\u0026#34;%s %s %s\u0026#34;, before, mystring, after) } } Ejecuci√≥n diferida Se puede usar la funci√≥n defer en funciones para realizar una acci√≥n antes de devolver el valor o resolver la funcion, y si se escribe m√°s de una, el orden en ejecuci√≥n de estas acciones es la contraria, como en learnDefer:\nfunc learnDefer() (ok bool) { // instrucciones diferidas se ejecutan antes de que la funci√≥n devuelva el resultado. defer fmt.Println (\u0026#34;deferred statements execute in reverse (LIFO) order.\u0026#34;) defer fmt.Println (\u0026#34;\\nThis line is being printed first because\u0026#34;) // defer se utiliza normalmente para cerrar un archivo despu√©s de abrirlo. return true } Interfaces Como ejemplo se define una funci√≥n llamada Stringer que contiene una funci√≥n llamada String; luego se define una estructura de dos d√≠gitos de tipo int nombrados x y y.\ntype Stringer interface { String() string } type pair struct { x, y int } Aqu√≠ se define la funci√≥n String como un pair, convirti√©ndose en un pair para la implementaci√≥n de la interfaz Stringer. La variable p a continuaci√≥n se llama receptor (receiver). Observar c√≥mo se accede a los campos de estructura de pair utilizando el nombre de la estructura seguido de un punto y luego el nombre del campo.\nfunc(p pair) String() string { return fmt.Sprintf (\u0026#34;(%d, %d)\u0026#34;, p.x, p.y) } Los puntos y comas se utilizan para crear un elemento de estructura (struct). Se usa la definici√≥n corta en el siguiente ejemplo para crear una variable llamada p y especificar su tipo en la estructura de pair.\nfunc learnInterfaces() { p := pair{3, 4} // llamar funci√≥n String de pair fmt.Println(p.String()) // definir una variable como i del tipo Stringer interface previamente definida var i Stringer // esta igualdad es correcta, porque se aplica pair de Stringer i = p // se llama funci√≥n String de la variable i de tipo Stringer y se obtiene // el mismo resultado que antes fmt.Println(i.String()) // al pasar las variables anteriores directamente a las funciones de impresi√≥n y salida fmt, // estas funciones llaman a la funci√≥n String para imprimir la representaci√≥n de la variable. */ // Las siguientes dos l√≠neas dan el mismo resultado de impresi√≥n fmt.Println(p) fmt.Println(i) learnVariadicParams (\u0026#34;great\u0026#34;, \u0026#34;learning\u0026#34;, \u0026#34;here!\u0026#34;) } M√∫ltiples entradas Es posible pasar variedad de variables a funciones sin un n√∫mero definido de par√°metros.\nfunc learnVariadicParams (myStrings... interface{}) { // la siguiente iteraci√≥n recorre los elementos de entrada de datos de la funci√≥n. for _, param: = range myStrings { fmt.Println(\u0026#34;param:\u0026#34;, param) } // se pasa la entrada de la funci√≥n variadica como par√°metro de otra funci√≥n (para Sprintln) fmt.Println (\u0026#34;params:\u0026#34;, fmt.Sprintln(myStrings...)) learnErrorHandling() } Manejo de errores La palabra clave \u0026ldquo;ok\u0026rdquo; se utiliza para determinar si una sentencia es correcta. Si ocurre un error, se puede usar una variable err para conocer m√°s detalles sobre el error.\nfunc learnErrorHandling() { m := map [int] string{3: \u0026#34;three\u0026#34;, 4: \u0026#34;four\u0026#34;} if x, ok := m[1]; !ok { // ok aqu√≠ ser√° falso porque el n√∫mero 1 no est√° en el mapa m fmt.Println(\u0026#34;no one there\u0026#34;) } else { // x ser√° el valor en el mapa fmt.Print(x) } // aqui se intenta convertir valor de texto a n√∫mero que resultar√° en un error, // se imprimen los detalles del error si err no es nil */ if _, err := strconv.Atoi(\u0026#34;non-int\u0026#34;); err != nil { fmt.Println(err) } learnConcurrency() } Ejecuci√≥n simult√°nea Usando una funci√≥n anterior para hacer una suma num√©rica a algunos n√∫meros en conjunto. Se usa make para crear una variable sin especificar un valor para ella.\nfunc learnConcurrency() { // se crea una variable de tipo canal llamada c c := make(chan int) // creando tres funciones Go concurrentes. Los n√∫meros se incrementar√°n simult√°neamente // (en paralelo si el dispositivo est√° configurado para hacerlo). // todas las transmisiones ir√°n al mismo canal // \u0026#34;go\u0026#34; aqu√≠ significa iniciar una nueva funci√≥n go inc(0, c) go inc(10, c) go inc(-805, c) // luego hacer tres lecturas desde el mismo canal e imprimir los resultados. // no hay un orden de acceso de lectura desde el canal, y // tambi√©n cuando el canal aparece a la derecha de la operaci√≥n // \u0026lt;- significa que esta leyendo y recibiendo del canal fmt.Println(\u0026lt;-c, \u0026lt;-c, \u0026lt;-c) // nuevo canal con texto cs := make(chan string) // canal contiene canales de texto ccs := make(chan chan string) // enviar valor 84 al canal c go func() {c \u0026lt;- 84}() // enviar palabra al canal cs go func() {cs \u0026lt;- \u0026#34;wordy\u0026#34;}() // instrucci√≥n select es similar a la instrucci√≥n switch, // pero en cada caso contiene un proceso para un canal que // est√° listo para comunicarse. select { // valor recibido del canal se puede guardar en una variable case i := \u0026lt;-c: fmt.Printf(\u0026#34;it\u0026#39;s a %T\u0026#34;, i) case \u0026lt;-cs: fmt.Println(\u0026#34;it\u0026#39;s a string\u0026#34;) // canal vac√≠o pero listo para comunicarse case \u0026lt;-ccs: fmt.Println(\u0026#34;didn\u0026#39;t happen.\u0026#34;) } } "},{"href":"https://gophers-latam.github.io/opensource/","title":"Open Source","body":"Software Open Source compartido en GitHub por Gophers LATAM.\n"},{"href":"https://gophers-latam.github.io/contacto/","title":"Contacto","body":"Medios de contacto con Gophers LATAM.\n"},{"href":"https://gophers-latam.github.io/colaboradores/","title":"Colaboradores","body":"Miembros p√∫blicos en github.com/gophers-latam\n"},{"href":"https://gophers-latam.github.io/biografia/","title":"Biograf√≠a","body":"Gophers LATAM es un esfuerzo conjunto por hacer una comunidad de programadores Golang en Espa√±ol-Latino.\nLos inicios son desde el canal de YouTube de Tom√°s Lingotti, luego se adopto la idea del Discord el cual ha sido impulsado desde el mismo canal y en otros canales de YouTube, tales como el de Golandia. Compartido en otros medios como Facebook, Twitter y Linkedin. Y con apoyo desde los inicios de zeroidentidad.\nOtra forma en la que se ha adoptado hacer presencia es en Github.\n\u0026ndash; Todo lo mencionado surgi√≥ desde octubre del 2020.\n"},{"href":"https://gophers-latam.github.io/proyectos/awesomelatam/","title":"Awesome Latam","body":"Colecci√≥n de contenidos y recursos principalmente en Espa√±ol para desarrolladores de Golang\n"},{"href":"https://gophers-latam.github.io/proyectos/go-tour/","title":"Go Tour","body":"Para aquellos que a√∫n no lo conocen, el \u0026lsquo;Tour de Go\u0026rsquo; representa una introducci√≥n excepcional al lenguaje de programaci√≥n Go. Ofrece ejemplos interactivos y explicaciones detalladas, convirti√©ndose en una herramienta invaluable para aquellos que desean aprender Go.\nComo comunidad, hemos realizado la traducci√≥n del sitio, permitiendo que cualquier persona de habla hispana tenga acceso a esta valiosa herramienta de aprendizaje.\nEstatus: Pendiente de aprobaci√≥n por el sitio oficial de Go (https://go-review.googlesource.com/c/website/+/545855).\n"},{"href":"https://gophers-latam.github.io/proyectos/gokey/","title":"GoKey","body":"GoKey es un cache en memoria. El principal aspecto es guardar, leer y borrar entradas dentro del ciclo de vida de la goroutine main. Es decir, si deja de correr, los datos se pierden.\nEstatus: ETAPA 1 - libreria cliente\n"},{"href":"https://gophers-latam.github.io/proyectos/gopherbot/","title":"Gopher-Bot","body":"Bot de discord como mascota y utilidad de comandos en server discord.me/gophers-latam.\nEl bot se encuentra inactivo debido a que kintohub ya dejo de dar servicio. "}]}