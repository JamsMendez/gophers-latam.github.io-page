{"results":[{"href":"https://gophers-latam.github.io/search/","title":"B칰squeda","body":""},{"href":"https://gophers-latam.github.io/posts/2021/04/golang-mantener-actualizado-el-sdk/","title":"Golang: Mantener actualizado el SDK","body":" Update Go  Como ocurre con todos los lenguajes de programaci칩n, hay actualizaciones peri칩dicas de las herramientas de desarrollo de Go. El SDK Go son binarios nativos que no dependen de un tiempo de ejecuci칩n independiente, por lo que no hay que preocuparse de que la actualizaci칩n del entorno de desarrollo pueda hacer que los programas actualmente implementados fallen. Puede tenerse programas compilados con diferentes versiones de Go ejecut치ndose simult치neamente en la misma computadora o m치quina virtual.\nDesde Go 1.2, ha habido una nueva versi칩n importante aproximadamente cada seis meses. Tambi칠n hay versiones menores con correcciones de errores y seguridad que se publican seg칰n sea necesario. Dados los r치pidos ciclos de desarrollo y el compromiso del equipo de Go con la compatibilidad con versiones anteriores, las versiones de Go tienden a ser incrementales en lugar de expansivas. La promesa de compatibilidad de Go es una descripci칩n detallada de c칩mo el equipo de Go planea evitar romper el c칩digo de Go. Dice que no habr치 cambios retr칩grados en el lenguaje o la librer칤a est치ndar para cualquier versi칩n de Go que comience con 1, a menos que el cambio sea necesario para un error o correcci칩n de seguridad. Sin embargo, puede haber (y ha habido) cambios incompatibles con versiones anteriores en los indicadores o la funcionalidad de los comandos go.\nA pesar de estas garant칤as de compatibilidad con versiones anteriores, los errores ocurren, por lo que es natural querer asegurarse de que una nueva versi칩n no rompa los programas personales ya hechos. Una opci칩n es instalar un entorno Go secundario. Por ejemplo, si actualmente se est치 ejecutando la versi칩n 1.15.2 y se quiere probar la versi칩n 1.16.3, debe usarse los siguientes comandos:\ngo get golang.org/dl/go.1.16.3 go1.16.3 download Luego se puede usar el comando go1.16.3 en lugar del comando go para ver si la versi칩n 1.16.3 funciona para los programas ya hechos anteriormente con la nueva versi칩n de Go:\ngo1.16.3 build Una vez que se haya validado que el c칩digo funciona, puede eliminarse el entorno secundario buscando el GOROOT, elimin치ndolo y luego eliminando el binario del directorio $GOPATH/bin. A continuaci칩n, las indicaciones de c칩mo hacerlo en Mac OS, Linux y BSD respectivamente:\ngo1.16.3 env GOROOT /Users/gobook/sdk/go1.16.3 rm -rf $(go1.16.3 env GOROOT) rm $(go env GOPATH)/bin/go1.16.3 Cuando se est치 listo para actualizar las herramientas de desarrollo de Go instaladas en la computadora, los usuarios de Mac y Windows tienen la ruta m치s f치cil. Aquellos que instalaron con brew o chocolatey pueden usar esas herramientas para actualizar. Aquellos que usaron los instaladores en golang.org/dl pueden descargar el 칰ltimo instalador, que elimina la versi칩n anterior cuando se instala la nueva.\nLos usuarios de Linux y BSD en general deben descargar la 칰ltima versi칩n, mover la versi칩n anterior a un directorio de respaldo, expandir la nueva versi칩n y luego eliminar la versi칩n anterior, algo as칤:\nmv /usr/local/go /usr/local/old-go tar -C /usr/local -xzf go1.16.3.linux-amd64.tar.gz rm -rf /usr/local/old-go Como nota final, igual en cada versi칩n que sale en el canal del Discord #游닗fuente-noticias se comparte autom치ticamente del canal de Twitter oficial como obtener la nueva versi칩n.\n"},{"href":"https://gophers-latam.github.io/posts/2021/04/golang-resumen-reglas/","title":"Golang: Resumen reglas","body":" Go Police  El lenguaje de programaci칩n Go fue creado para hacer el trabajo f치cilmente.\nGo tiene conceptos similares a los lenguajes imperativos y el tipado est치tico. Tambi칠n es r치pido en la compilaci칩n, r치pido de ejecutar e implementar. Grande y complejo.\nEn este post, se explican conceptos b치sicos de Go tratando algunos conceptos o reglas importantes.\nLos principales temas tratados son los siguientes:\n Escribir comentarios. Librer칤as e importaci칩n. Funciones. Tipos de datos. Valores de retorno con nombre. Variables y memoria. Control de sentencias. Generar funciones. Ejecuci칩n diferida. Interfaces. M칰ltiples entradas. Manejo de errores. Ejecuci칩n simult치nea.  Escribir comentarios: Para escribir un comentario de una l칤nea\n// comentario de una sola l칤nea Escribir un comentario con m치s de una l칤nea\n/* comentario de multi-l칤nea */ Librer칤as e importaci칩n: Cada archivo de c칩digo fuente comienza con la palabra clave package. La palabra clave main se utiliza para identificar el archivo como un archivo operativo, no como una librer칤a.\npackage main Para importar un paquete de la librer칤a est치ndar, terceros o personal al archivo, usamos la instrucci칩n import de la siguiente manera:\nimport ( \u0026#34;fmt\u0026#34; // paquete en la librer칤a est치ndar  \u0026#34;io/ioutil\u0026#34; // se aplican funciones de E/S  m \u0026#34;math\u0026#34; // usando la letra m para acortar o hacer alias del nombre de la librer칤a de funciones matem치ticas  \u0026#34;net/http\u0026#34; // web server  \u0026#34;os\u0026#34; // funciones a nivel del sistema operativo, como el manejo de archivos  \u0026#34;strconv\u0026#34; // conversiones de texto ) Funciones: Las funciones se definen mediante la palabra func seguida del nombre de la funci칩n.\nLa funci칩n main es privada y es la entrada al archivo ejecutable del programa (Go usa llaves ornamentadas {} para definir partes / bloques).\nfunc main() { // salida de texto en la unidad main en stdout (salida estandar) con Println de fmt (stdlib pkg)  fmt.Println (\u0026#34;Hello world!\u0026#34;) // llamar a una funci칩n del paquete actual  beyondHello() } Las funciones necesitan par칠ntesis que reciben par치metros, e incluso en ausencia de par치metros, se requieren par칠ntesis.\nfunc beyondHello() { // declaraci칩n de variable (la variable debe declararse antes de usarse)  var x int // dar valor a la variable  x = 3 // definici칩n corta usando := incluye definici칩n de variable, especificando su tipo y d치ndole valor  y := 4 // una funci칩n que devuelve dos valores separados  sum, prod := learnMultiple (x, y) // imprimir salida de forma sencilla y directa  fmt.Println (\u0026#34;sum:\u0026#34;, sum, \u0026#34;prod:\u0026#34;, prod) learnTypes() } La definici칩n de funci칩n puede tener m칰ltiples coeficientes y valores de retorno. Por ejemplo, learnMultiple toma los coeficientes x, y \u0026hellip; y devuelve dos valores de sum y prod de tipo Int.\nfunc learnMultiple (x, y int) (sum, prod int) { // separar los valores devueltos con una coma regular return x + y, x * y } Tipos de datos: func learnTypes() { // las declaraciones cortas generalmente cumplen el prop칩sito deseado  // definir una variable de texto usando comillas dobles  str := \u0026#34;Learn Go!\u0026#34; // definir una variable de texto con comillas simples  s2 := `A \u0026#34;raw\u0026#34; string literal can include line breaks.` // definir variable tipo runa que es otro nombre para el tipo int32 que contiene unicode  g := \u0026#39;풖\u0026#39; // float  f := 3.14195 // definici칩n de n칰mero complejo (Complex)  c := 3 + 4i // definir variables usando var  var u uint = 7 // n칰mero natural (entero positivo)  var pi float32 = 22. / 7 // un decimal de 32 bits  // definici칩n corta byte (es otro nombre para uint8)  n := byte (\u0026#39;\\n\u0026#39;) // arrays tienen un tama침o fijo, y son fijos en momento de compilaci칩n  // definir un array int de 4 elementos con un valor inicial de cero  var a4 [4] int // definir un array de 3 elementos con valores 3, 1 y 5  a3 := [...] int {3, 1, 5} Go ofrece un tipo de datos llamado Slices. Los Slices entendibles como \u0026ldquo;rebanadas\u0026rdquo;, \u0026ldquo;porciones\u0026rdquo;, \u0026ldquo;segmentos\u0026rdquo; tienen un tama침o din치mico. Las matrices (array) y los segmentos (slice) tienen ventajas, pero los casos de uso de los segmentos son m치s comunes. La siguiente instrucci칩n define un segmento de tipo int\n// observar la diferencia entre el array y la declaraci칩n del slice, donde cuando  // el slice est치 definido no hay un n칰mero que determine su tama침o  s3: = [] int {4, 5, 9} // definir un tipo int con cuatro elementos con valores cero  s4: = make ([] int, 4) // solo definir, y no hay selecci칩n  var d2 [] [] float64 // m칠todo para convertir el tipo de texto en slice  bs: = [] byte (\u0026#34;a slice\u0026#34;) Por la naturaleza de los slice din치micos, es posible agregar nuevos elementos usando la funci칩n append incorporada. Primero se pasa el slice al que queremos agregar y luego los elementos que queremos agregar.\ns := [] int {1, 2, 3} s = append (s, 4, 5, 6) // se imprimir치 un slice con el siguiente contenido [1 2 3 4 5 6]  fmt.Println (s) Para agregar un slice a otro slice, pasamos los dos slices en la funci칩n en lugar de pasar elementos individuales, y siguiendo el segundo slice con tres puntos.\ns = append (s, [] int {7, 8, 9} ...) // se imprimir치 un slice con el siguiente contenido [1 2 3 4 5 6 7 8 9]  fmt.Println (s) La siguiente instrucci칩n define las variables p y q como punteros en dos variables de tipo int que contienen dos valores devueltos por la funci칩n learnMemory:\np, q := learnMemory() // tema de reglas por ver Cuando un asterisco precede a un cursor, significa el valor de la variable a la que se refiere el cursor, como en el siguiente ejemplo los valores de las dos variables devueltas por la funci칩n learnMemory:\nfmt.Println (*p, *q) Los mapas (maps) en Go son arrays din치micos y modificables que son similares al tipo de diccionario o hash en otros lenguajes.\n// aqu칤 un mapa cuya clave es tipo texto y los valores de los elementos num칠ricos.  m: = map [string] int {\u0026#34;three\u0026#34;: 3, \u0026#34;four\u0026#34;: 4} m [\u0026#34;one\u0026#34;] = 1 Las variables no utilizadas son errores. El subrayado, guion bajo, operador blanco o Blank Identifier de la siguiente manera hace usar la variable pero ignora valores al mismo tiempo:\n_, _, _, _, _, _, _, _, _, _ = str, s2, g, f, u, pi, n, a3, s4, bs Valores de retorno con nombre: A diferencia de otros lenguajes, las funciones pueden tener valores de retorno con nombre. Donde el nombre se devuelve al valor de la funci칩n en la l칤nea de la definici칩n de la funci칩n, esta caracter칤stica permite regresar f치cilmente desde cualquier punto de la funci칩n adem치s del uso de la palabra return solo sin mencionar nada despu칠s:\nfunc learnNamedReturns (x, y int) (z int) { z = x * y // aqu칤 impl칤citamente significa devolver el valor de la variable z  return } Nota: El lenguaje Go se basa en gran medida en la recolecci칩n de basura. Go tiene indicadores pero no c치lculos (puede confundir un cursor vac칤o, pero no puede aumentar el cursor). Tener cuidado con valores de retorno de nil pointer reference.\nVariables y memoria: Las variables p y q a continuaci칩n son indicadores del tipo int y representan valores de retorno en la funci칩n. Cuando se define, los cursores est치n vac칤os; sin embargo, el uso de la funci칩n incorporada new hace que el valor de la variable num칠rica p se refiera a cero, y por lo tanto ocupa espacio en la memoria; es decir, p ya no est치 vac칤o.\nfunc learnMemory() (p, q* int) { p = new(int) // definir un slice de 20 elementos como una sola unidad en la memoria.  s := make([] int, 20) // dar valor a un elemento  s[3] = 7 // definir una nueva variable local a nivel de funci칩n  r := -2 // devolver dos valores de la funci칩n, que son direcciones de memoria  // para las variables s y r, respectivamente.  return \u0026amp;s[3], \u0026amp;r } func expensiveComputation() float64 { return m.Exp (10) } Control de sentencias Las sentencias condicionales requieren corchetes ornamentados y no requieren par칠ntesis.\nfunc learnFlowControl() { if true {fmt.Println (\u0026#34;told ya\u0026#34; ) } if false { // Rusters. } else { // Gophers. } Usar la instrucci칩n switch si se necesita escribir m치s de una secuencia condicional.\nx := 42.0 switch x { case 0: case 1: case 42: case 43: default: } Como sentencia condicional, la cl치usula for no toma par칠ntesis. Las variables definidas en la cl치usula for son visibles a nivel de la sentencia.\nfor x: = 0; x \u0026lt;3; x ++ { fmt.Println (\u0026#34;iteration\u0026#34;, x) } La instrucci칩n for es la 칰nica instrucci칩n de iteraci칩n en el lenguaje Go y tiene otra formas, de la siguiente manera:\n// repetici칩n infinita for { // break para detener la repetici칩n  break // continue para ir a la siguiente iteraci칩n  continue } Se puede utilizar el range para pasar elementos de array, slice, text string, map, channel.\nEl range de canal (channel) devuelve un valor, y dos valores cuando se usa en slice, array, text string, o map.\n// ejemplo: for key, value := range map [string] int {\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3} { // imprimir el valor de cada elemento del mapa  fmt.Printf (\u0026#34;key =% s, value =% d \\n\u0026#34;, key, value) } Usar el gui칩n bajo (_) contra valor de retorno en la clave si solo se desea el valor, de la siguiente manera:\nfor _, name: = range [] string {\u0026#34;Bob\u0026#34;, \u0026#34;Bill\u0026#34;, \u0026#34;Joe\u0026#34;} { fmt.Printf (\u0026#34;Hello,% s \\n\u0026#34;, name) } Se puede usar la declaraci칩n corta con la sentencia condicional para que se defina una variable y luego se verifique en la sentencia de condici칩n.\nPor ejemplo se define una variable y, se le da un valor y luego se coloca la condici칩n de la sentencia para que est칠n separadas por un punto y coma.\nif y := expensiveComputation(); y \u0026gt; x { x = y } Se puede definir funciones an칩nimas falsas directamente en el c칩digo.\nxBig := func() bool { // x:= 42 que fue declarada antes donde de menciona la sentencia switch  return x \u0026gt; 10000 } x = 99999 // la funci칩n xBig ahora devuelve el valor verdadero  fmt.Println (\u0026#34;xBig:\u0026#34;, xBig()) x = 1.3e3 // Despu칠s de modificar el valor de x a 1.3e3 que es igual a 1300 (es decir, mayor que 1000)  // la funci칩n xBig devuelve falso  fmt.Println (\u0026#34;xBig:\u0026#34;, xBig()) Adem치s de lo anterior, es posible definir funci칩n fantasma y llamarla en la misma l칤nea y pasarla a otra funci칩n siempre que se llame directamente y el tipo de resultado sea consistente con lo esperado en el par치metro de la funci칩n.\nfmt.Println (\u0026#34;Add + double two numbers:\u0026#34;, func (a, b int) int { return (a + b) * 2 } (10, 2)) goto love love: learnFunctionFactory() // Una funci칩n que devuelve una funci칩n  learnDefer() // Dormir  learnInterfaces() // Trabajar con interfaces } Generar funciones Se puede tratar las funciones como objetos separados. Por ejemplo, crear una funci칩n y el valor de retorno es otra.\nfunc learnFunctionFactory() { Los dos m칠todos siguientes para imprimir la oraci칩n son iguales, pero el segundo m칠todo es m치s claro, m치s legible y com칰n.\nfmt.Println(sentenceFactory (\u0026#34;summer\u0026#34;) (\u0026#34;A beautiful\u0026#34;, \u0026#34;day!\u0026#34;)) d: = sentenceFactory (\u0026#34;summer\u0026#34;) fmt.Println(d (\u0026#34;A beautiful\u0026#34;, \u0026#34;day!\u0026#34;)) fmt.Println(d (\u0026#34;A lazy\u0026#34;, \u0026#34;afternoon!\u0026#34;)) } Los decoradores se encuentran en algunos lenguajes de programaci칩n y en el mismo concepto en Go para que poder pasar datos a funciones.\nfunc sentenceFactory(mystring string) func(before, after string) string { return func(before, after string) string { return fmt.Sprintf (\u0026#34;%s %s %s\u0026#34;, before, mystring, after) } } Ejecuci칩n diferida Se puede usar la funci칩n defer en funciones para realizar una acci칩n antes de devolver el valor o resolver la funcion, y si se escribe m치s de una, el orden en ejecuci칩n de estas acciones es la contraria, como en learnDefer:\nfunc learnDefer() (ok bool) { // instrucciones diferidas se ejecutan antes de que la funci칩n devuelva el resultado.  defer fmt.Println (\u0026#34;deferred statements execute in reverse (LIFO) order.\u0026#34;) defer fmt.Println (\u0026#34;\\nThis line is being printed first because\u0026#34;) // defer se utiliza normalmente para cerrar un archivo despu칠s de abrirlo.  return true } Interfaces Como ejemplo se define una funci칩n llamada Stringer que contiene una funci칩n llamada String; luego se define una estructura de dos d칤gitos de tipo int nombrados x y y.\ntype Stringer interface { String() string } type pair struct { x, y int } Aqu칤 se define la funci칩n String como un pair, convirti칠ndose en un pair para la implementaci칩n de la interfaz Stringer. La variable p a continuaci칩n se llama receptor (receiver). Observar c칩mo se accede a los campos de estructura de pair utilizando el nombre de la estructura seguido de un punto y luego el nombre del campo.\nfunc(p pair) String() string { return fmt.Sprintf (\u0026#34;(%d, %d)\u0026#34;, p.x, p.y) } Los puntos y comas se utilizan para crear un elemento de estructura (struct). Se usa la definici칩n corta en el siguiente ejemplo para crear una variable llamada p y especificar su tipo en la estructura de pair.\nfunc learnInterfaces() { p := pair{3, 4} // llamar funci칩n String de pair  fmt.Println(p.String()) // definir una variable como i del tipo Stringer interface previamente definida  var i Stringer // esta igualdad es correcta, porque se aplica pair de Stringer  i = p // se llama funci칩n String de la variable i de tipo Stringer y se obtiene  // el mismo resultado que antes  fmt.Println(i.String()) // al pasar las variables anteriores directamente a las funciones de impresi칩n y salida fmt,  // estas funciones llaman a la funci칩n String para imprimir la representaci칩n de la variable. */  // Las siguientes dos l칤neas dan el mismo resultado de impresi칩n  fmt.Println(p) fmt.Println(i) learnVariadicParams (\u0026#34;great\u0026#34;, \u0026#34;learning\u0026#34;, \u0026#34;here!\u0026#34;) } M칰ltiples entradas Es posible pasar variedad de variables a funciones sin un n칰mero definido de par치metros.\nfunc learnVariadicParams (myStrings... interface{}) { // la siguiente iteraci칩n recorre los elementos de entrada de datos de la funci칩n.  for _, param: = range myStrings { fmt.Println(\u0026#34;param:\u0026#34;, param) } // se pasa la entrada de la funci칩n variadica como par치metro de otra funci칩n (para Sprintln)  fmt.Println (\u0026#34;params:\u0026#34;, fmt.Sprintln(myStrings...)) learnErrorHandling() } Manejo de errores La palabra clave \u0026ldquo;ok\u0026rdquo; se utiliza para determinar si una sentencia es correcta. Si ocurre un error, se puede usar una variable err para conocer m치s detalles sobre el error.\nfunc learnErrorHandling() { m := map [int] string{3: \u0026#34;three\u0026#34;, 4: \u0026#34;four\u0026#34;} if x, ok := m[1]; !ok { // ok aqu칤 ser치 falso porque el n칰mero 1 no est치 en el mapa m  fmt.Println(\u0026#34;no one there\u0026#34;) } else { // x ser치 el valor en el mapa  fmt.Print(x) } // aqui se intenta convertir valor de texto a n칰mero que resultar치 en un error,  // se imprimen los detalles del error si err no es nil */  if _, err := strconv.Atoi(\u0026#34;non-int\u0026#34;); err != nil { fmt.Println(err) } learnConcurrency() } Ejecuci칩n simult치nea Usando una funci칩n anterior para hacer una suma num칠rica a algunos n칰meros en conjunto. Se usa make para crear una variable sin especificar un valor para ella.\nfunc learnConcurrency() { // se crea una variable de tipo canal llamada c  c := make(chan int) // creando tres funciones Go concurrentes. Los n칰meros se incrementar치n simult치neamente  // (en paralelo si el dispositivo est치 configurado para hacerlo).  // todas las transmisiones ir치n al mismo canal  // \u0026#34;go\u0026#34; aqu칤 significa iniciar una nueva funci칩n  go inc(0, c) go inc(10, c) go inc(-805, c) // luego hacer tres lecturas desde el mismo canal e imprimir los resultados.  // no hay un orden de acceso de lectura desde el canal, y  // tambi칠n cuando el canal aparece a la derecha de la operaci칩n  // \u0026lt;- significa que esta leyendo y recibiendo del canal  fmt.Println(\u0026lt;-c, \u0026lt;-c, \u0026lt;-c) // nuevo canal con texto  cs := make(chan string) // canal contiene canales de texto  ccs := make(chan chan string) // enviar valor 84 al canal c  go func() {c \u0026lt;- 84}() // enviar palabra al canal cs  go func() {cs \u0026lt;- \u0026#34;wordy\u0026#34;}() // instrucci칩n select es similar a la instrucci칩n switch,  // pero en cada caso contiene un proceso para un canal que  // est치 listo para comunicarse.  select { // valor recibido del canal se puede guardar en una variable  case i := \u0026lt;-c: fmt.Printf(\u0026#34;it\u0026#39;s a %T\u0026#34;, i) case \u0026lt;-cs: fmt.Println(\u0026#34;it\u0026#39;s a string\u0026#34;) // canal vac칤o pero listo para comunicarse  case \u0026lt;-ccs: fmt.Println(\u0026#34;didn\u0026#39;t happen.\u0026#34;) } } "},{"href":"https://gophers-latam.github.io/opensource/","title":"Open Source","body":"Software Open Source en GitHub por Gophers LATAM.\n"},{"href":"https://gophers-latam.github.io/contacto/","title":"Contacto","body":"Medios de contacto con Gophers LATAM.\n"},{"href":"https://gophers-latam.github.io/colaboradores/","title":"Colaboradores","body":"Miembros p칰blicos en github.com/gophers-latam\n"},{"href":"https://gophers-latam.github.io/acerca/","title":"Acerca","body":"Gophers LATAM es un esfuerzo conjunto por hacer una comunidad de programadores Golang en Espa침ol-Latino.\nLos inicios son desde el canal YouTube de Tom치s Lingotti luego se adopto la idea del Discord el cual ha sido impulsado desde el mismo canal y en otros canales tal como el de Golandia y en otros medios como Facebook, Twitter y Linkedin. Como tambien desde blog de ZeroIdentidad.\nOtra forma en la que se esta adoptando hacer presencia es en Github.\n\u0026ndash; Todo lo mencionado anteriormente data desde oto침o del 2020.\n"},{"href":"https://gophers-latam.github.io/proyectos/awesomelatam/","title":"Awesome Latam","body":"Colecci칩n de contenidos y recursos principalmente en Espa침ol para desarrolladores de Golang\n"},{"href":"https://gophers-latam.github.io/proyectos/gopherbot/","title":"Gopher-Bot","body":"Bot de discord como mascota y utilidad de comandos en server discord.io/go-latam.\n El bot se encuentra inactivo debido a que kintohub ya dejo de dar servicio.  "}]}